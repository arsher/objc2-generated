//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

#[cfg(feature = "objc2")]
extern_class!(
    /// This class represents a file on an ICCameraDevice object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/imagecapturecore/iccamerafile?language=objc)
    #[unsafe(super(ICCameraItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "ICCameraItem", feature = "objc2"))]
    pub struct ICCameraFile;
);

#[cfg(all(feature = "ICCameraItem", feature = "objc2"))]
unsafe impl NSObjectProtocol for ICCameraFile {}

#[cfg(feature = "objc2")]
extern_methods!(
    #[cfg(all(feature = "ICCameraItem", feature = "objc2"))]
    unsafe impl ICCameraFile {
        /// Width of an image or movie frame.
        #[method(width)]
        pub unsafe fn width(&self) -> NSInteger;

        /// Height of an image or movie frame.
        #[method(height)]
        pub unsafe fn height(&self) -> NSInteger;

        /// Original filename on disk
        #[method_id(@__retain_semantics Other originalFilename)]
        pub unsafe fn originalFilename(&self) -> Option<Retained<NSString>>;

        /// Created filename
        #[method_id(@__retain_semantics Other createdFilename)]
        pub unsafe fn createdFilename(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "libc")]
        /// ￼Size of file in bytes.
        #[method(fileSize)]
        pub unsafe fn fileSize(&self) -> libc::off_t;

        #[cfg(feature = "ImageCaptureConstants")]
        /// ￼Desired orientation of image to use when it is downloaded.
        ///
        /// This property is set to ICEXIFOrientation1 initially. If the format of this file supports EXIF orientation tag, then this property will be updated to match the value of that tag, when the thumbnail or metadata for this file is received.
        #[method(orientation)]
        pub unsafe fn orientation(&self) -> ICEXIFOrientationType;

        #[cfg(feature = "ImageCaptureConstants")]
        /// Setter for [`orientation`][Self::orientation].
        #[method(setOrientation:)]
        pub unsafe fn setOrientation(&self, orientation: ICEXIFOrientationType);

        /// ￼Duration of audio/video file in seconds.
        #[method(duration)]
        pub unsafe fn duration(&self) -> c_double;

        /// True if file is a slo-mo or high framerate video file, nil otherwise.
        #[method(highFramerate)]
        pub unsafe fn highFramerate(&self) -> bool;

        /// True if file is a time-lapse video file, nil otherwise.
        #[method(timeLapse)]
        pub unsafe fn timeLapse(&self) -> bool;

        /// True if file is a firstPicked nil otherwise.
        #[method(firstPicked)]
        pub unsafe fn firstPicked(&self) -> bool;

        /// originatingAssetID of file if present, nil if not a HEIF or HVEC.
        #[method_id(@__retain_semantics Other originatingAssetID)]
        pub unsafe fn originatingAssetID(&self) -> Option<Retained<NSString>>;

        /// groupUUID of file if present, nil if file has no groupUUID.
        #[method_id(@__retain_semantics Other groupUUID)]
        pub unsafe fn groupUUID(&self) -> Option<Retained<NSString>>;

        /// GPS String in standard format.
        #[method_id(@__retain_semantics Other gpsString)]
        pub unsafe fn gpsString(&self) -> Option<Retained<NSString>>;

        /// Internal related UUID for dbg/aae/etc.
        #[method_id(@__retain_semantics Other relatedUUID)]
        pub unsafe fn relatedUUID(&self) -> Option<Retained<NSString>>;

        /// burstUUID of file if present, nil if not in a burst.
        #[method_id(@__retain_semantics Other burstUUID)]
        pub unsafe fn burstUUID(&self) -> Option<Retained<NSString>>;

        /// True if burst favorite, ignored if not in a burst or not a burst favorite.
        #[method(burstFavorite)]
        pub unsafe fn burstFavorite(&self) -> bool;

        /// True if burst user picked, ignored if not in a burst or not a burst user picked.
        #[method(burstPicked)]
        pub unsafe fn burstPicked(&self) -> bool;

        /// This property is NULL if there are no sidecar files associated with this file. Otherwise it is an array of
        /// ICCameraFile instances of sidecar files associated with this file. An example of a sidecar file is a file with the same base
        /// name as this file and having an extension XMP.
        #[method_id(@__retain_semantics Other sidecarFiles)]
        pub unsafe fn sidecarFiles(&self) -> Option<Retained<NSArray<ICCameraItem>>>;

        /// A single item subset of the sidecarFiles array, which contains the logical RAW compliment of a JPG or other
        /// format image.
        #[method_id(@__retain_semantics Other pairedRawImage)]
        pub unsafe fn pairedRawImage(&self) -> Option<Retained<ICCameraFile>>;

        /// Properties will either represent the actual file creation
        /// date, or nil.
        #[method_id(@__retain_semantics Other fileCreationDate)]
        pub unsafe fn fileCreationDate(&self) -> Option<Retained<NSDate>>;

        /// Properties will either represent the actual file modification
        /// date, or nil.
        #[method_id(@__retain_semantics Other fileModificationDate)]
        pub unsafe fn fileModificationDate(&self) -> Option<Retained<NSDate>>;

        /// Properties will either represent the exif creation
        /// date, or nil.
        #[method_id(@__retain_semantics Other exifCreationDate)]
        pub unsafe fn exifCreationDate(&self) -> Option<Retained<NSDate>>;

        /// Properties will either represent the exif modification
        /// date, or nil.
        #[method_id(@__retain_semantics Other exifModificationDate)]
        pub unsafe fn exifModificationDate(&self) -> Option<Retained<NSDate>>;

        /// A fingerprint generated from the camera file data
        /// date, or nil.
        #[method_id(@__retain_semantics Other fingerprint)]
        pub unsafe fn fingerprint(&self) -> Option<Retained<NSString>>;

        /// Generates a fingerprint given a URL
        /// date, or nil.
        #[method_id(@__retain_semantics Other fingerprintForFileAtURL:)]
        pub unsafe fn fingerprintForFileAtURL(url: &NSURL) -> Option<Retained<NSString>>;

        #[cfg(feature = "block2")]
        /// ￼Perform a thumbnail request and execute the block callback in place of the delegate.
        ///
        /// Parameter `options`: Options dictionary
        ///
        /// - 'kCGImageSourceThumbnailMaxPixelSize' - Request a width different from the embedded EXIF thumbnail
        ///
        ///
        /// Parameter `completion`: Completion block called with an NSData* object representing the JPG, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[method(requestThumbnailDataWithOptions:completion:)]
        pub unsafe fn requestThumbnailDataWithOptions_completion(
            &self,
            options: Option<&NSDictionary<ICCameraItemThumbnailOption, AnyObject>>,
            completion: &block2::Block<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Perform a metadata request and execute the block callback in place of the delegate.
        ///
        /// Parameter `options`: Options dictionary
        ///
        /// Parameter `completion`: Completion block called with an NSDictionary* object containing the metadata, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[method(requestMetadataDictionaryWithOptions:completion:)]
        pub unsafe fn requestMetadataDictionaryWithOptions_completion(
            &self,
            options: Option<&NSDictionary<ICCameraItemMetadataOption, AnyObject>>,
            completion: &block2::Block<dyn Fn(*mut NSDictionary, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Perform a download request and execute the block callback in place of the delegate.
        ///
        /// Parameter `options`: Dictionary Keys:
        ///
        /// - `ICDownloadsDirectoryURL`
        /// - `ICSaveAsFilename`
        /// - `ICOverwriteExistingFile`
        /// - `ICDeleteAfterDownload`
        /// - `ICAdjustCreationDate`
        ///
        ///
        /// Parameter `completion`: Completion block to executed after request has returned,
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[method_id(@__retain_semantics Other requestDownloadWithOptions:completion:)]
        pub unsafe fn requestDownloadWithOptions_completion(
            &self,
            options: Option<&NSDictionary<ICDownloadOption, AnyObject>>,
            completion: &block2::Block<dyn Fn(*mut NSString, *mut NSError)>,
        ) -> Option<Retained<NSProgress>>;

        #[cfg(all(feature = "block2", feature = "libc"))]
        /// This method asynchronously reads data of a specified length from a specified offset.
        ///
        /// Parameter `offset`: The offset into the file to start reading from
        ///
        /// Parameter `length`: The length of data to be read.
        ///
        /// Parameter `completion`: Completion block called with an NSData* object representing the data, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[method(requestReadDataAtOffset:length:completion:)]
        pub unsafe fn requestReadDataAtOffset_length_completion(
            &self,
            offset: libc::off_t,
            length: libc::off_t,
            completion: &block2::Block<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Requests a security scoped NSURL* for a media file on a mass storage volume. The returned NSURL* requires the use of
        /// startAccessingSecurityScopedResource, and stopAccessingSecurityScopedResource for access.
        ///
        /// Parameter `completion`: Completion block called with an NSURL*, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[method(requestSecurityScopedURLWithCompletion:)]
        pub unsafe fn requestSecurityScopedURLWithCompletion(
            &self,
            completion: &block2::Block<dyn Fn(*mut NSURL, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Requests a fingerprint be generated for camera file.
        ///
        /// Parameter `completion`: Completion block called with an NSString*, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[method(requestFingerprintWithCompletion:)]
        pub unsafe fn requestFingerprintWithCompletion(
            &self,
            completion: &block2::Block<dyn Fn(*mut NSString, *mut NSError)>,
        );
    }
);

#[cfg(feature = "objc2")]
extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "ICCameraItem", feature = "objc2"))]
    unsafe impl ICCameraFile {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
